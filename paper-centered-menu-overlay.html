<link href="../polymer/polymer.html" rel="import">

<link href="../core-overlay/core-overlay.html" rel="import">
<link href="paper-centered-menu-transition.html" rel="import">

<polymer-element name="paper-centered-menu-overlay" extends="core-overlay">
  <script>
    Polymer({

      publish: {
        relatedTarget: null,
        itemSize: 48,
        maxItems: 4,
        transition: 'paper-centered-menu-transition'
      },


      updateTargetDimensions: function() {
        this.measureTarget();
        this.super();
      },

      measureTarget: function() {
        var sizer = this.sizingTarget || this.target;

        sizer.style.position = 'absolute';
        sizer.style.left = '-99999px';
        sizer.style.top = '-99999px';

        var rect = sizer.getBoundingClientRect();

        this._naturalSize = {
          width: rect.width,
          height: rect.height
        };

        sizer.style.position = this.targetStyle.position;
        sizer.style.left = null;
        sizer.style.top = null;
      },


      countAbove: 0,

      positionTarget: function () {
        if (!this.relatedTarget) {
          this.super();
          return;
        }

        var menu = this.querySelector('#menu');
        var itemCount = menu.items.length;
        var overflowItems = this.maxItems - 1;
        var overflowAbove = Math.floor(overflowItems / 2);

        var maxAdditional = Math.min(
          Math.floor(itemCount / 2),
          Math.floor((this.maxItems) / 2)
        );

        var selected = menu.selected;
        var countAbove = Math.min(selected, maxAdditional, overflowAbove || 1);
        // Assign in here so the transition can access w/o more calc
        this.countAbove = countAbove;

        var top = -(countAbove * this.itemSize + 8);


        // update top in the case that we have selected near the end of the menu
        if (selected >= itemCount - maxAdditional) {
          var distanceFromEnd = itemCount - (selected + 1);
          var moveUp = maxAdditional - distanceFromEnd;
          top -= moveUp * this.itemSize;
        }

        // protect top from going over viewport
        var tRect = this.relatedTarget.getBoundingClientRect();
        top = Math.max(-tRect.top, top);


        var innerWidth = this.offsetWidth - 16 * 2;
        var left = - innerWidth / 2;
        var label = this.relatedTarget.querySelector('#label');
        left += label.offsetWidth / 2;

        var targetStyle = this.target.style;
        targetStyle.top = top + 'px';
        targetStyle.left = left + 'px';
      },


      sizeTarget: function () {
        var sizer = this.sizingTarget || this.target;

        sizer.style.width = this._naturalSize.width + 'px';
        sizer.style.height = (this.itemSize * this.maxItems + 16) + 'px';

        this.super();
      }

    });
  </script>
</polymer-element>
